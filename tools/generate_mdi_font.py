import freetype
import sys
import os

# Configuration
FONT_PATH = "EcoflowSTM32F4/fonts/materialdesignicons-webfont.ttf"
OUTPUT_PATH_C = "EcoflowSTM32F4/src/ui/font_mdi.c"
OUTPUT_PATH_H = "EcoflowSTM32F4/src/ui/font_mdi.h"
FONT_SIZE = 32  # Pixel size
FONT_NAME = "font_mdi"

# Icons Mapping: Name -> MDI Codepoint (Input)
# We will remap these to a continuous Private Use Area starting at 0xF000 (16-bit)
# to ensure they fit in LVGL's sparse map (BMP).
ICONS_INPUT = {
    "battery_100": 0xF0079,
    "battery_50": 0xF0079, # Duplicate for now
    "flash": 0xF01E4,
    "plug": 0xF0425,
    "solar": 0xF059F,
    "usb": 0xF050F,
    "power": 0xF042D,
    "check": 0xF012C,
    "close": 0xF0156,
    "wave": 0xF0588,
    "home": 0xF02DC,
    "cog": 0xF0493,
}

# Remap to 0xF000 .. 0xF000 + N
MAPPED_ICONS = {}
START_CODE = 0xF000

for i, (name, input_code) in enumerate(ICONS_INPUT.items()):
    MAPPED_ICONS[name] = {
        "input": input_code,
        "output": START_CODE + i
    }

# Add Basic ASCII
CHARS_ASCII = list(range(0x20, 0x7F))

def generate_font():
    if not os.path.exists(FONT_PATH):
        print(f"Error: Font file not found at {FONT_PATH}")
        return

    face = freetype.Face(FONT_PATH)
    face.set_pixel_sizes(0, FONT_SIZE)

    c_content = f"""#include "lvgl.h"

/*
 * Font: {FONT_NAME}
 * Size: {FONT_SIZE} px
 * Bpp: 1
 * Generated by script. Mapped to PUA 0xF000+
 */

"""

    bitmaps = []
    glyph_dsc = []
    current_bitmap_offset = 0
    unicode_list = []

    # Process ASCII (No Remap)
    for char_code in CHARS_ASCII:
        unicode_list.append(char_code)

        if char_code == 0x20: # Space
            glyph_dsc.append(f"    {{.bitmap_index = 0, .adv_w = {FONT_SIZE//2}, .box_w = 0, .box_h = 0, .ofs_x = 0, .ofs_y = 0}}")
            continue

        # For ASCII, we might need a different font file or assume MDI includes ASCII?
        # MDI usually does NOT include standard ASCII glyphs, only icons.
        # But we need to output *something* or use a fallback.
        # If MDI doesn't have 'A', we shouldn't include it in this font.
        # Actually, for this task, let's ONLY generate the ICONS and use LVGL's built-in font for text.
        # The user code uses `&font_mdi` for icons and `&lv_font_montserrat_xx` for text.
        # So we can DROP ASCII from this font to save space and confusion.
        pass

    # Reset lists for just Icons
    unicode_list = []
    glyph_dsc = []
    bitmaps = []
    current_bitmap_offset = 0

    sorted_names = sorted(MAPPED_ICONS.keys(), key=lambda k: MAPPED_ICONS[k]["output"])

    for name in sorted_names:
        item = MAPPED_ICONS[name]
        input_code = item["input"]
        output_code = item["output"]

        unicode_list.append(output_code)

        # Load by Input Code
        face.load_char(input_code, freetype.FT_LOAD_RENDER | freetype.FT_LOAD_TARGET_MONO)
        bitmap = face.glyph.bitmap
        width = bitmap.width
        rows = bitmap.rows
        pitch = bitmap.pitch
        buffer = bitmap.buffer

        # Extract bits
        char_bitmap_bytes = []
        for i in range(rows):
            for j in range((width + 7) // 8):
                if i * pitch + j < len(buffer):
                    char_bitmap_bytes.append(buffer[i * pitch + j])
                else:
                    char_bitmap_bytes.append(0)

        bitmaps.extend(char_bitmap_bytes)

        adv_w = face.glyph.advance.x >> 6
        ofs_x = face.glyph.bitmap_left
        ofs_y = face.glyph.bitmap_top - rows

        glyph_dsc.append(f"    {{.bitmap_index = {current_bitmap_offset}, .adv_w = {adv_w}, .box_w = {width}, .box_h = {rows}, .ofs_x = {ofs_x}, .ofs_y = {ofs_y}}}")
        current_bitmap_offset += len(char_bitmap_bytes)

    # Write Bitmap Array
    c_content += "static const uint8_t glyph_bitmap[] = {\n"
    for i in range(0, len(bitmaps), 12):
        chunk = bitmaps[i:i+12]
        c_content += "    " + ", ".join([f"0x{b:02X}" for b in chunk]) + ",\n"
    c_content += "};\n\n"

    # Write Glyph DSC
    c_content += "static const lv_font_fmt_txt_glyph_dsc_t glyph_dsc[] = {\n"
    c_content += ",\n".join(glyph_dsc)
    c_content += "\n};\n\n"

    # Write CMap
    c_content += "static const uint16_t unicode_list[] = {\n"
    for i, c in enumerate(unicode_list):
        if i > 0 and i % 12 == 0:
            c_content += "\n    "
        elif i == 0:
            c_content += "    "
        c_content += f"0x{c:04X}, "
    c_content += "\n};\n\n"

    c_content += """
static const lv_font_fmt_txt_cmap_t cmaps[] = {
    {
        .range_start = 0, .range_length = 0, .glyph_id_start = 0,
        .unicode_list = unicode_list, .glyph_id_ofs_list = NULL, .list_length = """ + str(len(unicode_list)) + """, .type = LV_FONT_FMT_TXT_CMAP_SPARSE_TINY
    }
};

"""

    c_content += f"""
static const lv_font_fmt_txt_dsc_t font_dsc = {{
    .glyph_bitmap = glyph_bitmap,
    .glyph_dsc = glyph_dsc,
    .cmaps = cmaps,
    .kern_dsc = NULL,
    .kern_scale = 0,
    .cmap_num = 1,
    .bpp = 1,
    .kern_classes = 0,
    .bitmap_format = 0
}};

const lv_font_t {FONT_NAME} = {{
    .get_glyph_dsc = lv_font_get_glyph_dsc_fmt_txt,
    .get_glyph_bitmap = lv_font_get_bitmap_fmt_txt,
    .line_height = {FONT_SIZE},
    .base_line = 0,
    .dsc = &font_dsc
}};
"""

    with open(OUTPUT_PATH_C, "w") as f:
        f.write(c_content)

    with open(OUTPUT_PATH_H, "w") as f:
        f.write(f"""#ifndef {FONT_NAME.upper()}_H
#define {FONT_NAME.upper()}_H

#include "lvgl.h"

extern const lv_font_t {FONT_NAME};

// Icon Definitions (Mapped to 0xF000+)
""")
        for name in sorted_names:
            code = MAPPED_ICONS[name]["output"]
            # UTF-8 for 0xFxxx range (3 bytes)
            # 1110xxxx 10xxxxxx 10xxxxxx
            b1 = 0xE0 | (code >> 12)
            b2 = 0x80 | ((code >> 6) & 0x3F)
            b3 = 0x80 | (code & 0x3F)
            utf8 = f"\\x{b1:02x}\\x{b2:02x}\\x{b3:02x}"

            f.write(f"#define MDI_{name.upper()} \"{utf8}\" // 0x{code:X}\n")

        f.write("\n#endif\n")

    print(f"Generated {OUTPUT_PATH_C} and {OUTPUT_PATH_H}")

if __name__ == "__main__":
    generate_font()
